from typing import List
from pydantic import BaseModel

from .clients import get_openai_client
from .parsing import chunk_text_from_pdf

class Insight(BaseModel):
    name: str
    summary: str
    reason: str

class InsightsReponse(BaseModel):
    insights: List[Insight]

def find_top_k_insights(path: str, top_k: int = 5, model: str = "gpt-4o-mini") -> List[str]:
    """
    Prompt model for the top-k most important insights in the document.
    :param path: The path to the document.
    :param top_k: How many insights to retrieve.
    :return: A list of the top k insights from the document generated by prompting a model with the document.
    """

    text_chunks = chunk_text_from_pdf(path)
    full_text = "\n\n".join(text_chunks)

    client = get_openai_client()

    response = client.beta.chat.completions.parse(
        model=model,
        messages=[
            {
                "role": "system",
                "content": (
                    "You are a world-class financial analyst that "
                    "identifies the most surprising or important"
                    "parts of a 10-K filing. Please be thorough."
                ),
            },
            {
                "role": "user",
                "content": (
                    f"Here is the text of a 10-K document:\n\n{full_text}\n\n"
                    f"Identify the top {top_k} most surprising or important pieces "
                    "of information that should be included in a summary for "
                    "investors. Respond with a short summary of each key insight. "
                    "For each insight, provide a brief reason why it is surprising "
                    "or important."
                )
            }
        ],
        temperature=0.3,
        max_tokens=1000,
        response_format=InsightsReponse
    )

    message = response.choices[0].message
    if message.parsed:
        insights = message.parsed.insights
        print({insight.name: f"{insight.summary} ({insight.reason})" for insight in insights})
        insights = {insight.name: insight.summary for insight in insights}
        if len(insights) < top_k:
            raise ValueError("Not enough insights from model completion.")
    else:
        raise ValueError("No parsed response from model completion.")

    return insights